% ----------------------------------------------------------------
%       Speech Signal Processing Toolkit (SPTK): version 3.0
%                      SPTK Working Group
% 
%                Department of Computer Science
%                Nagoya Institute of Technology
%                             and
%   Interdisciplinary Graduate School of Science and Engineering
%                Tokyo Institute of Technology
%                   Copyright (c) 1984-2000
%                     All Rights Reserved.
% 
% Permission is hereby granted, free of charge, to use and
% distribute this software and its documentation without
% restriction, including without limitation the rights to use,
% copy, modify, merge, publish, distribute, sublicense, and/or
% sell copies of this work, and to permit persons to whom this
% work is furnished to do so, subject to the following conditions:
% 
%   1. The code must retain the above copyright notice, this list
%      of conditions and the following disclaimer.
% 
%   2. Any modifications must be clearly marked as such.
%                                                                        
% NAGOYA INSTITUTE OF TECHNOLOGY, TOKYO INSITITUTE OF TECHNOLOGY,
% SPTK WORKING GROUP, AND THE CONTRIBUTORS TO THIS WORK DISCLAIM
% ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT
% SHALL NAGOYA INSTITUTE OF TECHNOLOGY, TOKYO INSITITUTE OF
% TECHNOLOGY, SPTK WORKING GROUP, NOR THE CONTRIBUTORS BE LIABLE
% FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
% DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
% WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
% ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
% PERFORMANCE OF THIS SOFTWARE.
% ----------------------------------------------------------------
%
\name{x2x}{data type transformation}{data operation}

\begin{synopsis}
\item[x2x] [ +$type1$ ] [ +$type2$ ] [ $\%format$ ] [ +$a$ A ] [ --r ]
\end{synopsis}

\begin{qsection}{DESCRIPTION}
The command {\em x2x} reads data from the standard input,
converts its data type, and sends the results to the standard
output.
\par
The input data type is assigned through the +$type1$ option,
and the output data type is assigned through the +$type2$ option.
\end{qsection}

\begin{options}
	\argp{type1}{input data type}{f}
	\argp{type2}{output data type\\
	both options $type1, type2$ can be assigned,
        one of the options below.\\
                \begin{tabular}{llcll} \\[-1zh]
                        c & char (1byte) & \quad &
                        C & unsigned char (1byte) \\
                        s & short (2bytes) & \quad &
                        S & unsigned short (2bytes) \\
                        i & int (4bytes) & \quad &
                        I & unsigned int (4bytes) \\
                        l & long (4bytes) & \quad &
                        L & unsigned long (4bytes) \\
                        f & float (4bytes) & \quad &
                        d & double (8bytes) \\
                        a & ASCII \\ [1zh] 
                \end{tabular} \\
                data type is converted from $t_1(type_1)$ to $t_2(type_2)$.
                if $t_2$ is not assigned then no operation is
                undertaken, and the output file is equal to the input
                file.}{type1}
	\argp{{\bf a} \qquad A}{column number}{1}
	\argm{r}{}{specify rounding off when a real number
                 is substituted for a integer}{FALSE}
	\argh{format}{}{specify output format similar to 'printf()', 
                        if $type2$ is ASCII.}{$\%g$}
\end{options}

\begin{qsection}{EXAMPLE}
The following example converts data in ASCII format
read from {\em data.asc}, converts to float format,
and writes the output to {\em data.f}:
\begin{quote}
  \verb!x2x +af < data.asc > data.f!
\end{quote}
\par
This example reads data in float format from {\em data.f}
converts to ASCII format, and sends the output to the screen:
\begin{quote}
  \verb!x2x +fa < data.f!
\end{quote}
For example, if contents of {\em data.f} in float format are
\begin{displaymath}
  1, 2, 3, 4, 5, 6, 7
\end{displaymath}
then the following output is printed to the screen.
\begin{quote}
  \verb!1! \\
  \verb!2! \\
  \verb!3! \\
  \verb!4! \\
  \verb!5! \\
  \verb!6! \\
  \verb!7!
\end{quote}
\par
If for the same data in the example above
the number of column is assigned:
column
\begin{quote}
  \verb!x2x +fa 3 < data.f!
\end{quote}
the output is
\begin{quote}
  \verb!1       2        3! \\
  \verb!4       5        6! \\
  \verb!7!
\end{quote}
\par
The output uses the printf command \%e format:
\begin{quote}
  \verb!x2x +fa %9.4e < data.f!
\end{quote}
In this example the total number of characters for each number
is 11, and the number of decimal points assigned to 4.
\begin{quote}
  \verb!1.0000e+000! \\
  \verb!2.0000e+000! \\
  \mbox{\hspace{2em}}$\vdots$ \\
  \verb!7.0000e+000!
\end{quote}
\end{qsection}

\begin{qsection}{SEE ALSO}
dmp
\end{qsection}
