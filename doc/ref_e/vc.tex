% ----------------------------------------------------------------- %
%             The Speech Signal Processing Toolkit (SPTK)           %
%             developed by SPTK Working Group                       %
%             http://sp-tk.sourceforge.net/                         %
% ----------------------------------------------------------------- %
%                                                                   %
%  Copyright (c) 1984-2007  Tokyo Institute of Technology           %
%                           Interdisciplinary Graduate School of    %
%                           Science and Engineering                 %
%                                                                   %
%                1996-2012  Nagoya Institute of Technology          %
%                           Department of Computer Science          %
%                                                                   %
% All rights reserved.                                              %
%                                                                   %
% Redistribution and use in source and binary forms, with or        %
% without modification, are permitted provided that the following   %
% conditions are met:                                               %
%                                                                   %
% - Redistributions of source code must retain the above copyright  %
%   notice, this list of conditions and the following disclaimer.   %
% - Redistributions in binary form must reproduce the above         %
%   copyright notice, this list of conditions and the following     %
%   disclaimer in the documentation and/or other materials provided %
%   with the distribution.                                          %
% - Neither the name of the SPTK working group nor the names of its %
%   contributors may be used to endorse or promote products derived %
%   from this software without specific prior written permission.   %
%                                                                   %
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND            %
% CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,       %
% INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF          %
% MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE          %
% DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS %
% BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,          %
% EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED   %
% TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,     %
% DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON %
% ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,   %
% OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY    %
% OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE           %
% POSSIBILITY OF SUCH DAMAGE.                                       %
% ----------------------------------------------------------------- %
\hypertarget{vc}{}
\name[ref:vc-IEEETASLP]{vc}{GMM-based voice conversion}{voice conversion}
\def\vec#1{\mbox{\boldmath $#1$}}
\def\dim#1{^{(#1)}}
\def\inv{^{-1}}
\def\mid{\:|\:}
\def\trans{^{\top}}
\def\W{\Vec{W}}
\def\w{\Vec{w}}
\def\sX{\vec{\scriptstyle{X}}}
\def\sY{\vec{\scriptstyle{Y}}}
\def\sZ{\vec{\scriptstyle{Z}}}
\def\sm{\vec{\scriptstyle{m}}}
\def\sv{\vec{\scriptstyle{v}}}
\newcommand{\argmax}{\mathop{\rm argmax}\limits}
\newcommand{\Sum}{\displaystyle\sum\limits}
\newcommand{\Prod}{\prod\limits}

\begin{synopsis}
\item[vc] [ --l $L_1$ ]  [ --n $N_1$ ]  [ --L $L_2$ ]  [ --N $N_2$ ]
           [ --m $M$ ]  [ --d ($fn$ $|$ $d_0$ [$d_1$ $\dots$]) ]
\item [\ ~~~~] [ --r $N_R$ $W_1$ [$W_2$] ] [ --g $gvfile$ ] {\em gmmfile}
 [ {\em infile} ]
\end{synopsis}

\begin{qsection}{DESCRIPTION}
 {\em vc} carries out a GMM-based non-linear parameter conversion based on the
 maximum-likelihood estimation of a parameter trajectory~\cite{ref:vc-IEEETASLP}.
 Furthermore, {\em vc} supports a parameter conversion considering Global Variance
 (GV) of the target feature vectors.  {\em vc} converts the source static feature
 vector sequence from {\em infile} (or standard input) into the target static feature
 vector sequence, and sends the results to standard output. The {\em gmmfile} must be
 specified to carry out the conversion and it must have the same file format as the
 one generated by the {\em gmm} command (cross or full covariance).

 Both input and output are in float format.

 Let vectors $\vec{x}$ and $\vec{y}$ be time sequence of the $D$-dimensional source
 and target feature vectors, respectively.  They can be written as
 \begin{align*}
  \vec{x} & = \left[\vec{x}_{1}\trans, \vec{x}_{2}\trans, \ldots,
                 \vec{x}_{t}\trans,\ldots, \vec{x}_{T}\trans,\right]\trans, \\
  \vec{y} & = \left[\vec{y}_{1}\trans, \vec{y}_{2}\trans, \ldots,
                 \vec{y}_{t}\trans,\ldots, \vec{y}_{T}\trans,\right]\trans.
 \end{align*}
 where the notation ${}\trans$ denotes transposition of the vector.  Furthermore,
 $2D$-dimensional source and target feature vectors are defined as $\vec{X}_{t} =
 \left[\vec{x}_{t}\trans, \Delta\vec{x}_{t}\trans\right]\trans$ and $\vec{Y}_{t} =
 \left[\vec{y}_{t}\trans, \Delta\vec{y}_{t}\trans\right]\trans$ consisting of
 $D$-dimensional static and dynamic features at frame $t$.  Their time sequence are
 written as
  \begin{align*}
  \vec{X} & = \left[\vec{X}_{1}\trans, \vec{X}_{2}\trans, \ldots,
                 \vec{X}_{t}\trans,\ldots, \vec{X}_{T}\trans,\right]\trans, \\
  \vec{Y} & = \left[\vec{Y}_{1}\trans, \vec{Y}_{2}\trans, \ldots,
                 \vec{Y}_{t}\trans,\ldots, \vec{Y}_{T}\trans,\right]\trans.
 \end{align*}
 The dynamic features are often calculated as regression coefficients from their
 neighboring static features, i.e.,
  \begin{align*}
  \Delta \vec{x}_{t} &= \Sum_{\tau=-L\dim{1}_{-}}^{L\dim{1}_{+}}
 w\dim{1}(\tau)\vec{x}_{t + \tau}
  \end{align*}
 where $\{ w\dim{1}(\tau)\}_{\tau=-L\dim{1}_{-},\ldots,L\dim{1}_{+}}$ are window
 coefficients to calculate the first order dynamic feature.  The relationship between
 a sequence of the static feature vectors $\vec{y}$ and that of the static and
 dynamic feature vectors $\vec{Y}$ can be arranged in a matrix form as
 \begin{align*}
  \vec{Y} = \vec{W} \vec{y}
 \end{align*}
 $\W$ is a $2DT \times DT$ window matrix and the elements of $\W$ are given as
 follows:
 \begin{align*}
 \W &= \left[
         \begin{array}{ccccc}
          \W_{1}
           &
           \ldots
           &
           \W_{t}
           &
           \ldots
           &
           \W_{T}
         \end{array}
         \right]\trans\otimes \Vec{I}_{M\times M},\\
 \W_{t} &= \left[\w\dim{0}_t, \w\dim{1}_{t}\right],\\
 \w\dim{d}_{t} &= \Bigl[\underbrace{0,\ldots,0}_{t-L\dim{d}_{-}-1},
  w\dim{d}(-L\dim{d}_{-}),\ldots,w\dim{d}(0),\nonumber \ldots,
  w\dim{d}(L\dim{d}_{+}),\underbrace{0,\ldots,0}_{T-\left(t+L\dim{d}_{+}\right)}
  \Bigl]\trans, \hspace{2mm} d=0,1
 \end{align*}
 where $L\dim{0}_{-} = L\dim{0}_{+} = 0$, $\w\dim{0} = 1$, and $\otimes$ denotes the
 Kronecker product for matrices. Delta-delta features can also be used
 straightforwardly.

 The GMM $\vec{\lambda\dim{\sZ}}$ of the joint p.d.f.~$P(\vec{Z}_{t}\mid
 \vec{\lambda\dim{\sZ}})$ is trained in advance using joint vectors $\vec{Z}_{t} =
 \left[\vec{X}_{t}\trans,\vec{Y}_{t} \right]\trans$:
 \begin{align*}
  P(\vec{Z}_{t}\mid \vec{\lambda\dim{\sZ}})
  &= \Sum_{m=1}^{M}w_{m} \mathcal{N}(\vec{Z}_{t}; \vec{\mu}\dim{\sZ}_{m},
  \vec{\Sigma}\dim{\sX}_{m}),
 \end{align*}
 where the weight of the $m$-th mixture weight is $w_m$,
 the normal distribution with $\vec{\mu}$ and $\vec{\Sigma}$ is denoted as
 $\mathcal{N}(\cdot; \vec{\mu}, \vec{\Sigma})$ and the number of mixture component is
 $M$.  The mean vector $\vec{\mu}\dim{\sZ}_{m}$ and the covariance matrix
 $\vec{\Sigma}\dim{\sX}_{m}$ of the $m$-th mixture component can be written as
 \begin{align*}
  \vec{\mu}\dim{\sZ}_{m}
  &=
  \left[
  \begin{array}{c}
   \vec{\mu}\dim{\sX}_{m} \\
   \vec{\mu}\dim{\sY}_{m}
  \end{array}
  \right],
  \;\;\;
  \vec{\Sigma}\dim{\sZ}_{m} =
  \left[
  \begin{array}{cc}
   \vec{\Sigma}\dim{\sX\sX}_{m} & \vec{\Sigma}\dim{\sX\sY}_{m}\\
   \vec{\Sigma}\dim{\sY\sX}_{m} & \vec{\Sigma}\dim{\sY\sY}_{m}
  \end{array}
  \right],
 \end{align*}
 where $\vec{\mu}\dim{\sX}_{m}$ and $\vec{\mu}\dim{\sY}_{m}$ are the mean vector of
 the $m$-th mixture component for the source and that for target, respectively. The
 matrices $\vec{\Sigma}\dim{\sX\sX}_{m}$ and $\vec{\Sigma}\dim{\sY\sY}_{m}$ are the
 covariance matrix of the $m$-th mixture component for the source and that for
 target, respectively.  The matrices $\vec{\Sigma}\dim{\sX\sY}_{m}$ and
 $\vec{\Sigma}\dim{\sY\sX}_{m}$ are the cross-covariance matrix of the $m$-th mixture
 component for the source and that for target, respectively.

 A time sequence of the converted feature vectors can be determined based on
 maximization of the likelihood function:
 \begin{align*}
  \hat{\vec{y}} &= \argmax_{\vec{y}} \;P\left(\vec{Y}\mid \vec{X},
  \vec{\lambda}\dim{\sZ}\right)\\
  & = \argmax_{\vec{y}} \Sum_{\mathrm{all}\; \sm}
  P\left(\vec{m}\mid \vec{X}, \vec{\lambda\dim{\sZ}} \right)
  P\left(\vec{Y} \mid \vec{X}, \vec{m}, \vec{\lambda\dim{\sZ}}\right) \\
  & \approx \argmax_{\vec{y}} P\left(\hat{\vec{m}}\mid \vec{X}, \vec{\lambda\dim{\sZ}} \right)
  P\left(\vec{Y} \mid \vec{X}, \hat{\vec{m}}, \vec{\lambda\dim{\sZ}}\right) \\
  & = \argmax_{\vec{y}} \Prod_{t=1}^{T} P\left(\hat{m_{t}} \mid \vec{X}_{t},
  \vec{\lambda\dim{\sZ}} \right)
  P\left(\vec{Y}_{t} \mid \vec{X}, \hat{m_{t}}, \vec{\lambda\dim{\sZ}}\right),
 \end{align*}
 where $\vec{m} = \{m_{1}, m_{2}, \ldots, m_{t}, \ldots, m_{T}\}$ is a mixture
 component sequence, $\hat{\vec{m}}$ is the sum-optimum mixture component sequence
 determined by
 \begin{align*}
  \hat{\vec{m}} = \arg\max P\left(\vec{m}\mid \vec{X}, \vec{\lambda\dim{\sZ}}\right).
 \end{align*}
 The $m$-th mixture component weight $P\left(m\mid \vec{X}_{t},
 \vec{\lambda\dim{\sZ}} \right)$ and the $m$-th conditional probability distribution
 $P\left(\vec{Y}_{t} \mid \vec{X}, m, \vec{\lambda\dim{\sZ}}\right)$ at frame $t$ are
 given by
 \begin{align*}
  P\left(m\mid \vec{X}_{t}, \vec{\lambda\dim{\sZ}} \right)
  &= \frac{w_{m} \mathcal{N}\left(\vec{X}_{t} ;
  \vec{\mu}\dim{\sX}_{m}, \vec{\Sigma}\dim{\sX\sX}_{m}\right)}
  {\sum_{n=1}^{M} w_{n} \mathcal{N}\left(\vec{X}_{t} ;
  \vec{\mu}\dim{\sX}_{n}, \vec{\Sigma}\dim{\sX\sX}_{n}\right)},
  \end{align*}
 \begin{align*}
  P\left(\vec{Y}_{t} \mid \vec{X}, m, \vec{\lambda\dim{\sZ}}\right)
  &= \mathcal{N}\left(\vec{Y}_{t} ; \vec{E}\dim{\sY}_{m,t},
  \vec{D}\dim{\sY}_{m}\right),
  \end{align*}
 where
 \begin{align*}
  \vec{E}\dim{\sY}_{m,t} &= \vec{\mu}\dim{\sY}_{m}
  + \vec{\Sigma}\dim{\sY\sX}_{m} {\vec{\Sigma}\dim{\sX\sX}_{m}}\inv
  \left(\vec{X}_{t} - \vec{\mu}\dim{\sX}_{m}\right), \\
  \vec{D}\dim{\sY}_{m} &= \vec{\Sigma}\dim{\sY\sY}_{m} 
  + \vec{\Sigma}\dim{\sY\sX}_{m} {\vec{\Sigma}\dim{\sX\sX}_{m}}\inv
  \vec{\Sigma}\dim{\sX\sY}_{m}.
 \end{align*}

 The converted static feature vector sequence $\hat{\vec{y}}$ can be obtained as
 \begin{align*}
  \hat{\vec{y}} &=\left(\W\trans {\vec{D}\dim{\sY}_{\hat{\sm}}}\inv \W\right)\inv
  \W\trans {\vec{D}\dim{\sY}_{\hat{\sm}}}\inv \vec{E}\dim{\sY}_{\hat{\sm}},
 \end{align*}
 where
 \begin{align*}
 \vec{E}\dim{\sY}_{\hat{\sm}}
  &= \left[
  \begin{array}{cccccc}
   \vec{E}^{(\sY)\top}_{\scriptstyle \hat{m_1}, 1}
    &
    \vec{E}^{(\sY)\top}_{\scriptstyle \hat{m_2}, 2}
    &
    \ldots
    &
    \vec{E}^{(\sY)\top}_{\scriptstyle \hat{m_t}, t}
    &
    \ldots
    &
    \vec{E}^{(\sY)\top}_{\scriptstyle \hat{m_T}, T}
  \end{array}
  \right]\trans,\\
   \vec{D}\dim{\sY}_{\hat{\sm}} &=
  \left[
   \begin{array}{cccccc}
    \vec{D}\dim{\sY}_{\scriptstyle \hat{m_1}} & & & & & \vec{0}\\
    & \vec{D}\dim{\sY}_{\scriptstyle \hat{m_2}}  & & & & \\
    & & \ddots  & & & \\
    & & & \vec{D}\dim{\sY}_{\scriptstyle \hat{m_t}} & &  \\
    & & & & \ddots & \\
    \vec{0} & & & & &
     \vec{D}\dim{\sY}_{\scriptstyle \hat{m_T}}
   \end{array}
  \right].
\end{align*}

To cope with the over-smoothing problem of the converted features, {\em vc} can also
carry out the conversion considering GV.  The GV $\vec{v}(\vec{y})$ of the target
static feature vectors $\vec{y}$ is defined as
\begin{align*}
 \vec{v}(\vec{y}) &= \left[v(1), v(2), \ldots, v(d), \ldots, v(D)\right]\trans \\
 v(d) &= \frac{1}{T} \Sum_{t=1}^{T} (y_{t}(d) - \overline{y}(d))^{2} \\
 \overline{y}(d) &= \frac{1}{T} \Sum_{t=1}^{T} y_{t}(d)
\end{align*}
where $y_{t}(d)$ is the $d$-th component of $y_{t}$.  The GV $\vec{v}(\vec{y})$ is
assumed to be normally distributed with mean vector $\vec{\mu}\dim{\sv}$ and the
covariance matrix $\vec{\Sigma}\dim{\sv\sv}$:
 \begin{align*}
  P\left(\vec{v}(\vec{y})\mid \vec{\lambda\dim{\vec{v}}}\right)
  &= \mathcal{N}\left(\vec{v}(\vec{y});
  \vec{\mu}\dim{\sv}, \vec{\Sigma}\dim{\sv\sv} \right), \\
  \vec{\lambda\dim{\vec{v}}} & =
  \left\{ \vec{\mu}\dim{\sv}, \vec{\Sigma}\dim{\sv\sv} \right\}.
 \end{align*}
 A time sequence of the converted feature vectors considering GV can be determined as
 follows:
 \begin{align*}
  \hat{\vec{y}} &= \argmax_{\vec{y}} \;P\left(\vec{Y}\mid \vec{X},
  \vec{\lambda}\dim{\sZ}, \vec{\lambda\dim{\vec{v}}} \right) \\
  & = \argmax_{\vec{y}} \;P\left(\vec{Y}\mid \vec{X},
  \vec{\lambda}\dim{\sZ} \right)^{\omega}
  P\left( \vec{v}(\vec{y}) \mid \vec{\lambda\dim{\vec{v}}} \right) \\
  &\approx \argmax_{\vec{y}}
  \left\{P\left(\hat{\vec{m}}\mid \vec{X}, \vec{\lambda\dim{\sZ}} \right)
  P\left(\vec{Y} \mid \vec{X}, \hat{\vec{m}}, \vec{\lambda\dim{\sZ}}\right)
  \right\}^{\omega}
  P\left( \vec{v}(\vec{y}) \mid \vec{\lambda\dim{\vec{v}}} \right)
 \end{align*}
 where $\omega$ is the weight for controlling the balance between the two
 likelihoods.  The approximated log-likelihood function can be introduced as
 \begin{align*}
  \mathcal{L} &= \log \left[
  \left\{ P\left(\hat{\vec{m}}\mid \vec{X}, \vec{\lambda\dim{\sZ}} \right)
  P\left(\vec{Y} \mid \vec{X}, \hat{\vec{m}}, \vec{\lambda\dim{\sZ}}\right)
  \right\}^{\omega}
  P\left( \vec{v}(\vec{y}) \mid \vec{\lambda\dim{\vec{v}}} \right)\right].
 \end{align*}
 The converted parameter trajectory can be updated iteratively using
 the first derivative of $\mathcal{L}$ given by
 \begin{align*}
  \frac{\partial \mathcal{L}}{\partial \vec{y}}
  & = \omega \left(
  - \W\trans {\vec{D}\dim{\sY}_{\hat{\sm}}}\inv \W \vec{y}
  + \W\trans {\vec{D}\dim{\sY}_{\hat{\sm}}}\inv \vec{E}\dim{\sY}_{\hat{\sm}}
  \right)
  + \left[{\vec{v}^{\prime}_{1}}\trans,
  {\vec{v}^{\prime}_{2}}\trans,
  \ldots,
  {\vec{v}^{\prime}_{t}}\trans,
  \ldots,
  {\vec{v}^{\prime}_{T}}\trans
  \right]\trans, \\
  \vec{v}^{\prime}_{t}
  &= \left[v^{\prime}_{t}(1), v^{\prime}_{t}(2),
  \ldots, v^{\prime}_{t}(d), \ldots, v^{\prime}_{t}(D)\right]\trans, \\
  v^{\prime}_{t}(d)
  &= -\frac{2}{T} {\vec{c}_{\sv}\dim{d}}\trans
  \left(\vec{v}(\hat{\vec{y}}) - \vec{\mu}_{\sv}\right)
  \left(\hat{y}_{t}(d) - \overline{\hat{y}}(d) \right),
 \end{align*}
 where ${\vec{c}_{\sv}\dim{d}}\trans$ is the $d$-th column vector of
 $\vec{\Sigma\dim{\sv\sv}}\inv$.
\end{qsection}

\begin{options}
 \argm{l}{L_1}{dimension of source feature vector}{25}
 \argm{n}{N_1}{order of source feature vector}{$L_1-1$}
 \argm{L}{L_2}{dimension of target feature vector}{$L_1$}
 \argm{N}{N_2}{order of target feature vector}{$L_2-1$}
 \argm{m}{M}{number of mixture components of GMM}{16}

 \argm{d}{(fn~|~d_0~[d_1~\dots])} {$fn$ is the file name of the parameters
 $w^{(n)}(\tau)$ used when evaluating the dynamic feature vector.  It is assumed that
 the number of coefficients to the left and to the right are the same.  Therefore,
 the number of coefficients must be odd.  Instead of entering the file name $fn$, the
 coefficients(which compose the file $fn$) can be directly inputted from the command
 line. }{N/A}

 \argm{r}{N_R~W_1~[W_2]}{ This option is used when $N_R$-th order dynamic parameters
 are used and the weighting coefficients $w^{(n)}(\tau)$ are evaluated by regression.
 $N_R$ can be made equal to 1 or 2.  The variables $W_1$ and $W_2$ represent the
 widths of the first and second order regression coefficients, respectively.  The
 first and second order regression coefficients at frame $t$ are evaluated likewise
 {\em delta} command.  }{N/A}

 \argm{g}{gvfile}{$gvfile$ is the file name of GV statistics of the target static
 feature vectors. $gvfile$ must contain the mean vector and diagonal components of
 covariance matrix of the Gaussian distribution of the GV.  }{N/A}
\end{options}

\begin{qsection}{EXAMPLE}
In the following example, the source and target features (24-th order Mel-cepstrum
coefficients) are extracted from the file {\em source.raw} and the file {\em
target.raw} of raw (short) format.  These extracted features are concatenated by {\em
dtw} command, which can perform a Dynamic Time Warping.  The GMM {\em
source\_target.gmm} can be trained by using the joint features.
\begin{quote}
\verb!x2x +sf < source.raw | frame -l 400 -p 80 | \! \\
\verb!    window -l 400 -L 1024 -w 0 | \! \\
\verb!    mcep -l 1024 -m 24 -a 0.42 > source.mcep ! \\
\verb!x2x +sf < target.raw | frame -l 400 -p 80 | \! \\
\verb!    window -l 400 -L 1024 -w 0 | \! \\
\verb!    mcep -l 1024 -m 24 -a 0.42 > target.mcep ! \\
\verb!dtw -l 25 -p 5 -n 2 target.mcep < source.mcep | \! \\
\verb!    gmm -l 50 -m 2 -f > source_target.gmm!
\end{quote}
Using the {\em source\_target.gmm} and the source features extracted from the file
{\em source\_test.raw}, under the same analysis condition above, the GMM-based
spectral parameter conversion can be performed and the converted target static
features are saved as {\em target\_test.mcep}.
\begin{quote}
\verb!x2x +sf < source_test.raw | frame -l 400 -p 80 | \! \\
\verb!    window -l 400 -L 1024 -w 0 | \! \\
\verb!    mcep -l 1024 -m 24 -a 0.42 | \! \\
\verb!    vc -l 25 -m 2 -r 1 1 source_target.gmm \! \\
\verb!    > target_test.mcep!
\end{quote}
Finally, using the {\em target\_test.mcep}, the waveform can be synthesized as {\em
 target\_test.raw}.
\begin{quote}
\verb!excite -p 80 target.pitch | \! \\
\verb!    mlsadf -m 24 -p 80 -a 0.42 -P 5 target_test.mcep | \! \\
\verb!    x2x +fs -o > target_test.raw!
\end{quote}
where the {\em target.pitch} must be prepared in advance.  Usually, the target $F_0$
can be obtained by a linear transform in a log-domain, from a log-scaled $F_0$ of the
source speaker~\cite{ref:vc-IEEETASLP}.  This transform can be realized by using {\em
pitch}, {\em sopr} and {\em vstat} command.
\end{qsection}

\begin{qsection}{SEE ALSO}
\hyperlink{gmm}{gmm},
\hyperlink{pitch}{pitch},
\hyperlink{sopr}{sopr},
\hyperlink{vstat}{vstat}
\end{qsection}
