\name{sopr}{execute scalar operations}{number operation}

\begin{synopsis}
\item[sopr]   [ --a $A$ ] [ --s $S$ ] [ --m $M$ ] [ --d $D$ ] [ --ABS ] [ --INV ]
\item[\ ~~~~]  [ --P ] [ --R ] [ --SQRT ] [ --LN ] [ --LOG10 ] [ --EXP ] [ --POW10 ] 
\item[\ ~~~~] [ --FIX ] [ --UNIT ] [ --CLIP ] [ --SIN ] [ --COS ] [ --TAN ] 
\item[\ ~~~~] [ --ATAN ] [ --r m$n$ ] [ --w m$n$ ] [ {\em infile} ]
\end{synopsis}

\begin{qsection}{DESCRIPTION}
This command reads input data $x$ from the assigned file,
undertakes assigned scalar operation and
sends the results to the standard output.
If {\em infile} is not assigned,
then data is read from the standard input.
\par
Input and output data are in float format.
\par
The operations are undertaken with the assigned order.
\end{qsection}

\begin{options}
	\argm{a}{A}{addition $y=x+A$}{FALSE}
	\argm{s}{S}{subtraction $y=x-S$}{FALSE}
	\argm{m}{M}{multiplication $y=x\ast M$}{FALSE}
	\argm{d}{D}{division $y=x/D$}{FALSE}
	\desc[1zh]{If the argument of the operation option is
                ``{\em dB}'' then the value $20/\log_e10$
                is assigned.
		Also similary, if ``{\em pi}'' is written after
                the operation option, then its value will be used.
                Actuary expression such as ``{\em ln2}'',
                ``{\em exp10}'', ``{\em sqrt30}'' can also be
                used as arguments.}
	\argm[1zh]{ABS}{}{absolute $y=|x|$}{FALSE}
	\argm{INV}{}{inverse $y=1/x$}{FALSE}
	\argm{P}{}{square $y=x^2$}{FALSE}
	\argm{R}{}{square root $y=\sqrt{x}$}{FALSE}
	\argm{SQRT}{}{square root $y=\sqrt{x}$}{FALSE}
	\argm{LN}{}{logarithm $y=\log{x}$}{FALSE}
	\argm{LOG10}{}{logarithm $y=\log_{10}{x}$}{FALSE}
	\argm{EXP}{}{exponential $y=\exp{x}$}{FALSE}
	\argm{POW10}{}{power of 10 $y=10^x$}{FALSE}
	\argm{FIX}{}{round $(int)x$бе}{FALSE}
	\argm{UNIT}{}{unit step $u(x)$}{FALSE}
	\argm{CLIP}{}{clipping $x \ast u(x)$}{FALSE}
	\argm{SIN}{}{sin $y=\sin(x)$}{FALSE}
	\argm{COS}{}{cos $y=\cos(x)$}{FALSE}
	\argm{TAN}{}{tan $y=\tan(x)$}{FALSE}
	\argm{ATAN}{}{atan $y=\atan(x)$}{FALSE}

        \argm{r}{\mbox{m}n}{read from memory regisiter m$n$ $(n=0..9)$}{}
        \argm{w}{\mbox{m}n}{write from memory regisiter m$n$ $(n=0..9)$}{}
\end{options}

\begin{qsection}{EXAMPLE}
In the following example, a ramp function($0,1,2,\ldots$)
is mutiplied by 2 ($0,2,4,\ldots$)
and then 1 is added ($1,3,5,\ldots$):
\begin{quote}
  \verb!ramp | sopr -m 2 -a 1 | dmp!
\end{quote}
\par
The output file {\em data.avrg} contains the average taken from
data in files {\em data.f1} and {\em data.f2} read in float format:
\begin{quote}
  \verb!vopr -a data.f1 data.f2 | sopr -d 2 > data.avrg!
\end{quote}
\par
Data is read in float format from {\em data.f},
and the results in dB is written to the output:
\begin{quote}
  \verb!sopr data.f -LN -m dB | dmp!
\end{quote}
The following example gives the same results:
\begin{quote}
  \verb!sopr data.f -LOG10 -m 20 | dmp!
\end{quote}
\par
If we want to evaluate the followin equation,
\[
y = (1 + 3x + 4x^2) / (1 + 2x + 5x^2) 
\]
then memory registers can be used as follows.
\begin{quote}
\verb!sopr data.f -w m0 -m 5 -a 2 -m m0 -a 1 -w m1 \!\\
\verb!       -r m0 -m 4 -a 3 -m m0 -a 1 -d m1 | dmp!
\end{quote}
In the example above, m0 and m1 are memory registers.
Regisers from m0 to m9 can be used.
The --w option is used to write into memory register,
while the --r option is used to read from a register.
\end{qsection}

\begin{qsection}{SEE ALSO}
  vopr, vsum
\end{qsection}
