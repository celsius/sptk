\name{lbg}{ベクトル量子化器設計のための LBG アルゴリズム}{none}

\begin{synopsis}
\item [lbg] [ --l $L$ ] [ --n $N$ ] [ --t $T$ ] [ --s $S$ ] [ --e $E$ ]
        [ --f $F$ ] [ --v ] [ --d $D$ ] [ --r $R$ ] 
\item [\ ~~~~] [ {\em index\_file} ] $<$ {\em infile}
\end{synopsis}

\begin{qsection}{DESCRIPTION}
 {\em lbg}は，lbg アルゴリズムによりコードブックの学習を行ないます．
データ形式は入力，出力ともに float 型です．

lbg アルゴリズムでは，標準入力から与えるベクトルサイズ $L$，
のトレーニングベクトル系列
\begin{displaymath} 
\mbox{\boldmath x}(0), \mbox{\boldmath x}(1), \ldots, \mbox{\boldmath x}(T-1)
\end{displaymath}
からコードブック
\begin{displaymath}
\mbox{\boldmath C}_E =\{ \mbox{\boldmath c}_E(0), \mbox{\boldmath c}_E(1), 
\ldots, \mbox{\boldmath c}_E(E-1) \}
\end{displaymath}
を求め，標準出力に出力します．次のアルゴリズムにより，
コードブックを作成します．

\begin{description}
\item[\bf step.0~~~] 初期コードブックが指定された場合は，それを$\mbox{\boldmath C}_S$
とし，そうでない場合は，すべてのトレーニングデータのセントロイド
\begin{displaymath}
\mbox{\boldmath c}_1(0) = \frac{1}{T} \sum_{n=0}^{T-1} \mbox{\boldmath x}(n)
\end{displaymath}
を求め，
$\mbox{\boldmath C}_1 = \{ \mbox{\boldmath c}_1(0) \},S = 1$とします．

\item[\bf step.1~~~] コードブック$\mbox{\boldmath C}_S$を$\mbox{\boldmath C}_{2S}$にします．
この時長さ$L$の正規乱数$\mbox{\boldmath rnd}$および，splitting factor $R$
を用いて，
\begin{displaymath}
\mbox{\boldmath c}_{2S}(n)=\left\{ \begin{array}{ll}
\mbox{\boldmath c}_S(n) + R \cdot \mbox{\boldmath rnd} & ( 0 \le n \le S-1 ) \\
\mbox{\boldmath c}_S(n) - R \cdot \mbox{\boldmath rnd} & ( S \le n \le 2S-1 )
\end{array}\right.
\end{displaymath}
とします．$D_0 = \infty, k = 0$とします．

\item[\bf step.2~~~] 現在のコードブック$\mbox{\boldmath C}_{2S}$に対して，
トレーニングベクトルを量子化します．
その後，トレーニングベクトルと，コードベクトルとの平均ユークリッド距離$D_k$
を求め，終了条件$D$を用いて，
\begin{displaymath}
|\frac{D_{k-1}-D_{k}}{D_{k}}| < D
\end{displaymath}
の場合 {\bf step.4} に進み，それ以外の場合は {\bf step.3} に進みます．

\item[\bf step.3~~~] {\bf step.2} で得られた結果からセントロイドを求め，
コードブック$\mbox{\boldmath C}_{2S}$を更新します．
ただし，量子化した結果，インデックス$i$にトレーニングベクトルが
一つも割り当てられなかった場合は，最も割り当てられた数が
多いコードベクトル$\mbox{\boldmath c}_{2S}(j)$を用いて
\begin{displaymath}
\mbox{\boldmath c}_{2S}(i)=\mbox{\boldmath c}_{2S}(j) + R \cdot \mbox{\boldmath rnd}
\end{displaymath}
として求めます．その後 $k=k+1$ として，{\bf step.2} に戻ります．

\item[\bf step.4~~~] $2S = E$ なら終了，そうでなければ$S$ = $2S$として{\bf step.1}に戻ります．

\end{description}
\end{qsection}

\begin{options}
	\argm{l}{L}{ベクトルのサイズ．}{26}
	\argm{n}{N}{ベクトルの次数．}{25}
	\argm{t}{T}{トレーニングベクトル数．
		     \\入力がパイプでない場合は省略できます．}{N/A}
	\argm{s}{S}{初期コードブックサイズ．}{1}
	\argm{e}{E}{最終コードブックサイズ．2のべき乗で指定．}{256}
	\argm{f}{F}{初期コードブックファイルネーム．}{NULL}
	\argm{v}{}{verbose モード．verbose.log に計算経過を出力する．}{FALSE}
	\desc[1zh]{通常，以下のオプションの指定は必要ありません．}
	\argm{d}{D}{終了条件．}{0.0001}
	\argm{r}{R}{splitting factor}{0.0001}
\end{options}

\begin{qsection}{EXAMPLE}
float形式の25 次のトレーニングベクトル {\em data.f} からコードブック
サイズ 256 のコードブックを作成し，{\em cbfile}に出力します:
\begin{quote}
\verb! lbg < data.f > cbfile!
\end{quote}
\end{qsection}

\begin{qsection}{SEE ALSO}
vq, ivq, msvq
\end{qsection}
